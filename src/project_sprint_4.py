# -*- coding: utf-8 -*-
"""Project Sprint 4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16wydXJxQvaqozNPrAIt2_RVpeJRMqQ8x

# Prepaid Plan Analysis

## Introduction

In this project, we aim to compare the two plans offered by Megaline (Not a real company) to understand which plan is the most profitable. This analysis will be based on a relatively small sample of 500 Megaline clients, containing information such as their identity, location, the type of plan they use, and the number of calls and messages they sent in 2018. Our task is to analyze client behavior and determine which prepaid plan generates more revenue.

## Prepaid Plan Descriptions

### Surf Plan
- **Monthly Fee:** $20

- **Included Monthly Usage:**
  - 500 minutes of call duration
  - 50 SMS
  - 15 GB of data
- **Charges Beyond Limits:**
  - 3 cents per minute
  - 3 cents per SMS
  - $10 per GB of data

### Ultimate Plan
- **Monthly Fee:** $70

- **Included Monthly Usage:**
  - 3000 minutes of call duration
  - 1000 SMS
  - 30 GB of data
- **Charges Beyond Limits:**
  - 1 cent per minute
  - 1 cent per SMS
  - $7 per GB of data

## Methodology

To achieve the project goal, we will test two hypotheses:
1. The average usage of line service for Surf's clients and Ultimate's clients is the same.
2. The average revenue of the NY-NJ area is the same as other areas.

## Data Preparation and Processing

During the data processing, we encountered several obstacles and took corrective actions to ensure the data is valid for analysis. The procedures are detailed below:

### User Data
- The `churn_date` column has blank values because those customers are still using the service. These blanks will be left unchanged as they do not affect other data.
- The `reg_date` and `churn_date` columns are in object format but should be in date format. These will be reformatted using `to_datetime`.

### Calls Data
- The `call_date` column is in object format but should be in date format. This will be reformatted using `to_datetime`.

### Messages Data
- The `message_date` column is in object format but should be in date format. This will be reformatted using `to_datetime`.

### Internet Data
- The `session_date` column is in object format but should be in date format. This will be reformatted using `to_datetime`.

After correcting the data formats, we will continue with the following steps:
1. Creating columns necessary for analysis (usage of each service and its revenue and total revenue).
2. Categorizing states to differentiate the NY-NJ area from other states.
3. Combining all data into a single dataset named `main_data_6`.

## Data Description

### Users Table
- `user_id`: Unique user ID
- `first_name`: User's first name
- `last_name`: User's last name
- `age`: User's age (in years)
- `reg_date`: Subscription start date (dd, mm, yy)
- `churn_date`: Date the user stopped using the service (blank if still using)
- `city`: User's city
- `plan`: Name of the phone plan

### Calls Table
- `id`: Unique call ID
- `call_date`: Call date
- `duration`: Call duration (in minutes)
- `user_id`: ID of the user who made the call

### Messages Table
- `id`: Unique SMS ID
- `message_date`: Date the SMS was sent
- `user_id`: ID of the user who sent the SMS

### Internet Table
- `id`: Unique web session ID
- `mb_used`: Data volume used during the session (in megabytes)
- `session_date`: Date of the web session
- `user_id`: ID of the user

### Plans Table
- `plan_name`: Name of the phone plan
- `usd_monthly_fee`: Monthly fee (in USD)
- `minutes_included`: Monthly call duration allocation (in minutes)
- `messages_included`: Monthly SMS allocation
- `mb_per_month_included`: Monthly data allocation (in megabytes)
- `usd_per_minute`: Price per minute beyond the plan allocation
- `usd_per_message`: Price per SMS beyond the plan allocation
- `usd_per_gb`: Price per GB of additional data beyond the plan allocation (1 GB = 1024 megabytes)

## Analysis Steps

1. **Open the data files and explore general information.**
2. **Prepare the data:**
   - Convert data types as needed.
   - Identify and correct any data errors.
   - Document any errors found and how they were corrected.
3. **For each user, calculate:**
   - Number of calls made and minutes used per month.
   - Number of SMS sent per month.
   - Data volume used per month.
   - Monthly revenue from each user (subtract the free plan limits from the total usage and apply the relevant charges, then add the monthly plan fee).
4. **Analyze the data:**
   - Describe consumer behavior by identifying the minutes, messages, and data usage per month for each plan.
   - Calculate the average, variance, and standard deviation.
   - Create histograms and describe the distributions.
5. **Test the hypotheses:**
   - Determine if the average revenue from Ultimate and Surf plan users is different.
   - Determine if the average revenue from users in the NY-NJ area is different from users in other areas.
   - Specify the alpha value for hypothesis testing.
   - Explain the null and alternative hypotheses formulation.
   - Describe the criteria used for hypothesis testing and the rationale.

## **Data Loading and Initial Examination**
"""

!pip install --upgrade pandas

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats as st
from scipy.stats import ttest_ind

data_user = pd.read_csv('/content/megaline_users.csv')
data_calls = pd.read_csv('/content/megaline_calls.csv')
data_messages = pd.read_csv('/content/megaline_messages.csv')
data_internet = pd.read_csv('/content/megaline_internet.csv')
data_plans = pd.read_csv('/content/megaline_plans.csv')

"""**User Dataset**


"""

data_user.head()

data_user.isnull().sum()

data_user.info()

data_user.duplicated().sum()

"""Based on the given data:

- The `churn_date` column has blank values because those customers are still using our service.
- The `reg_date` and `churn_date` columns are in object format but should be in date format.

Explanation of Each Column

Users Table
- `user_id` — User ID
- `first_name` — User's first name
- `last_name` — User's last name
- `age` — User's age (in years)
- `reg_date` — Subscription start date (dd, mm, yy)
- `churn_date` — Date the user stopped using the service (if blank or missing, the service is still in use at the time of data creation)
- `city` — User's city of residence
- `plan` — Name of the phone plan

**Calls Dataset**
"""

data_calls.head()

data_calls.info()

data_calls.isnull().sum()

data_calls.duplicated().sum()

"""Based on the given data:

- The `churn_date` column has blank values because those customers are still using our service.
- The `reg_date` and `churn_date` columns are in object format but should be in date format.

Explanation of Each Column

Users Table:
- `user_id` — User ID
- `first_name` — User's first name
- `last_name` — User's last name
- `age` — User's age (in years)
- `reg_date` — Subscription start date (dd, mm, yy)
- `churn_date` — Date the user stopped using the service (if blank or missing, the service is still in use at the time of data creation)
- `city` — User's city of residence
- `plan` — Name of the phone plan

**Calls Dataset**
"""

data_calls.head()

data_calls.info()

data_calls.isnull().sum()

data_calls.duplicated().sum()

"""Based on data given:

column call_date has object format when it is supposed to be date format.
Here are the explanation of each column:

- `id`: ID panggilan unik
- `call_date`: tanggal panggilan
- `duration`: durasi panggilan (dalam menit)
- `user_id`: ID pengguna yang melakukan panggilan

**Messages Dataset**
"""

data_messages.head(5)

data_messages.info()

data_messages.isnull().sum()

data_messages.duplicated().sum()

"""Based on data given:

column message_date has object format when it is supposed to be date format.
Here are the explanation of each column:

- `id`: Unique SMS ID
- `message_date`: Date the SMS was sent
- `user_id`: User ID of the sender

**Internet Dataset**
"""

data_internet.head()

data_internet.info()

data_internet.isnull().sum()

data_internet.duplicated().sum()

"""Based on data given:

column session_date has object format when it is supposed to be date format.
Here are the explanation of each column:

- `id`: Unique web session ID
- `mb_used`: Data volume used during the session (in megabytes)
- `session_date`: Date of the web session
- `user_id`: User ID

**Plan Dataset**
"""

data_plans.head()

data_plans.info()

"""Based on data given:

Here are the explanation of each column:

- `plan_name`: Name of the phone plan
- `usd_monthly_fee`: Monthly fee in US dollars
- `minutes_included`: Monthly allocation of call minutes
- `messages_included`: Monthly allocation of SMS messages
- `mb_per_month_included`: Monthly allocation of data volume (in megabytes)
- `usd_per_minute`: Price per minute if usage exceeds the allocated minutes (e.g., if the plan includes 100 minutes, any usage beyond the 100th minute incurs this charge)
- `usd_per_message`: Price per SMS if usage exceeds the allocated messages
- `usd_per_gb`: Price per additional gigabyte of data if usage exceeds the allocated data (1 GB = 1024 megabytes)

## **Data Preprocessing**

### **Fixing datatype**

**User Dataset**
"""

data_user['reg_date'] = pd.to_datetime(data_user['reg_date'], format='%Y-%m-%d')
data_user['churn_date'] = pd.to_datetime(data_user['churn_date'], format='%Y-%m-%d')

data_user['reg_date'].describe()

data_user.sample(5)

data_user.info()

"""**Calls Dataset**"""

data_calls['call_date'] = pd.to_datetime(data_calls['call_date'], format='%Y-%m-%d')

data_calls.sample(5)

data_calls.info()

"""**Messages Dataset**"""

data_messages['message_date'] = pd.to_datetime(data_messages['message_date'], format='%Y-%m-%d')

data_messages.sample(5)

data_messages.info()

"""**Internet Dataset**"""

data_internet['session_date'] = pd.to_datetime(data_internet['session_date'], format='%Y-%m-%d')

data_internet.sample(5)

data_internet.info()

"""### **Categorize date to month and year**

We will categorize date data into month so it is easier to analyze
"""

def to_month(dataset, col_name):
    temp = pd.to_datetime(dataset[col_name])
    temp = temp.dt.to_period("M")
    return temp

data_calls['month'] = to_month(data_calls, 'call_date')
data_calls.head()

data_messages['month'] = to_month(data_messages, 'message_date')
data_messages.head()

data_internet['month'] = to_month(data_internet, 'session_date')
data_internet.head()

"""### **Extract State Name from Addrress Column**

As stated in the project description, we will analyse the revenue in certain state in USA. So it is important to categorize the state based on the city data given
"""

data_user['clean_city'] = data_user['city'].str.split(', ').str[1]
data_user['clean_city'] = data_user['clean_city'].str.replace(' MSA', '')
data_user.head()

"""As we can see the state is in clean_city column

Since we will observe the revenue in NY-NJ state we will put sign to indicate those state by creating new column named nynj
"""

data_user['clean_city'].unique()

"""Since NY-NJ include in NY-NJ-PA, we can use this PA and will calculate the average, so it wont bother much. Moreover, PA or Pensylvania is a state next to NY and NJ so the carhacteristic is the same"""

data_user['nynj'] = data_user['clean_city'].str.contains('NY-NJ-PA', regex=True)
data_user['nynj'] = data_user['nynj'].replace(True, 1).replace(False, 0)
data_user.head()

data_user.sample()

"""### **Rounding the calls duration**"""

data_calls['duration'] = np.ceil(data_calls['duration']).astype('int16')
data_calls

"""As stated in project description, now we will round up the monthly usage of line service for each customer."""

data_calls_agg = pd.pivot_table(data_calls, index=['user_id', 'month'], values='duration', aggfunc= 'sum').reset_index()
data_calls_agg

num_zero_duration_calls = (data_calls_agg['duration'] == 0).sum()

print((num_zero_duration_calls/len(data_calls_agg))*100)

data_calls_agg.loc[data_calls_agg['duration'] == 0]

"""As we can see these data do not influence another data, and it is known that 0 value means miss calls so we can not count that as substraction of plan. Therefore it is okay for us to leave it that way.

we can see there are some outliers, but since there are also possibilities that people do actually in call for that long and we are not looking for conclusion of habit then we can ignore this.

### **Categorizing monthly text**
"""

data_message_agg = pd.pivot_table(data_messages, index=['user_id', 'month'], values='id', aggfunc='count').reset_index()
data_message_agg.columns = ['user_id', 'month', 'sms']
data_message_agg.head()

"""### **Categorizing monthly data**"""

data_internet_agg = pd.pivot_table(data_internet, index=['user_id', 'month'], values='mb_used', aggfunc='sum').reset_index()
data_internet_agg

data_internet_agg['gb_used'] = data_internet_agg['mb_used'] / 1024
data_internet_agg

data_internet_agg['gb_used'] = np.ceil(data_internet_agg['gb_used']).astype('int16')
data_internet_agg

data_plans.columns = ['messages_included',
                      'mb_per_month_included',
                      'minutes_included',
                      'usd_monthly_pay',
                      'usd_per_gb',
                      'usd_per_message',
                      'usd_per_minute',
                      'plan']

"""### **Cross Join the data**

To make the data easier to analyze and make sure that nothing were left off, we will make cross join the data with the primary key of user_id and month
"""

pd.DataFrame(data_internet_agg['month'].unique(), columns=['month']).sort_values(by='month')

pd.DataFrame(data_calls_agg['month'].unique(), columns=['month']).sort_values(by='month')

pd.DataFrame(data_message_agg['month'].unique(), columns=['month']).sort_values(by='month')

temp_month = pd.DataFrame(data_internet_agg['month'].unique(), columns=['month']).sort_values(by='month')
temp_month['key'] = 1
temp_month

temp_users = pd.DataFrame(data_user['user_id'].unique(), columns=['user_id']).sort_values(by='user_id')
temp_users['key'] = 1
temp_users.head()

main = temp_users.merge(temp_month, how='inner', on='key').drop('key', axis=1)
main.tail()

"""Now we have our cross join data, we will join the data one by one

Calculation of minute calls and number off calls

We will add column that consist of number of call per customer per month
"""

data_calls_agg_2 = pd.pivot_table(data_calls, index=['user_id', 'month'], values='duration', aggfunc='count').reset_index()
data_calls_agg_2

main_data = main.merge(data_calls_agg, how='left', on=['user_id', 'month'])
main_data.columns = ['user_id', 'month', 'minute call']
main_data

main_data_2 = main_data.merge(data_calls_agg_2, how='left', on=['user_id', 'month'])
main_data_2.columns = ['user_id', 'month', 'minute_call', 'call_num']
main_data_2

"""Calculation of SMS sent by user per month"""

main_data_3 = main_data_2.merge(data_message_agg, how='left', on=['user_id', 'month'])
main_data_3

"""Calculation of Internet by user per month"""

main_data_4 = main_data_3.merge(data_internet_agg, how='left', on=['user_id', 'month'])
main_data_4

"""Join all of the data"""

main_data_5 = main_data_4.merge(data_user, how='left', on='user_id')
main_data_5.head(2)

main_data_6 = main_data_5.merge(data_plans, how='left', on='plan')
main_data_6.head(2)

main_data_6.drop(['mb_used', 'reg_date', 'churn_date', 'age'], axis=1, inplace=True)
main_data_6.info()

"""All set, the data final named as main_data_6

Filling the missing value with 0
"""

main_data_6[['minute_call', 'call_num', 'sms', 'gb_used']] = main_data_6[['minute_call', 'call_num', 'sms', 'gb_used']].fillna(0)

main_data_6.info()

"""### **Calculation of user usage**

Calls
"""

main_data_6['extra_calls'] = (main_data_6['minute_call'] - main_data_6['minutes_included']) * main_data_6['usd_per_minute']

main_data_6.loc[main_data_6['extra_calls'] < 0, 'extra_calls'] = 0

"""Messages"""

main_data_6['extra_sms'] = (main_data_6['sms'] - main_data_6['messages_included']) * main_data_6['usd_per_message']

main_data_6.loc[main_data_6['extra_sms'] < 0, 'extra_sms'] = 0

"""Internet"""

main_data_6['gb_per_month_included'] = main_data_6['mb_per_month_included'] / 1024

main_data_6['gb_per_month_included']

main_data_6['extra_internet'] = (main_data_6['gb_used'] - main_data_6['gb_per_month_included']) * main_data_6['usd_per_gb']

main_data_6.loc[main_data_6['extra_internet'] < 0, 'extra_internet'] = 0

"""Now since we have revenue from each service, lets add them up to get the total revenue"""

main_data_6['total_income'] = main_data_6['usd_monthly_pay'] + main_data_6['extra_calls'] + main_data_6['extra_sms'] + main_data_6['extra_internet']
main_data_6.head(2)

"""## **Exploratory Data Analysis**

Now we will devide the main data into 2 based on the plan (Surf and Ultimate)
"""

data_surf = main_data_6.loc[main_data_6['plan'] == 'surf'].reset_index(drop=True)

data_surf.info()

data_ultimate = main_data_6.loc[main_data_6['plan'] == 'ultimate'].reset_index(drop=True)

data_ultimate.info()

"""### **Calls**

Now we will compare the characteristic of data calls between Surf and Ultimate
"""

surf_call_avg = pd.pivot_table(data_surf, index='month', values='minute_call', aggfunc='mean').reset_index()
ultimate_call_avg = pd.pivot_table(data_ultimate, index='month', values='minute_call', aggfunc='mean').reset_index()

plt.bar(surf_call_avg.index, surf_call_avg['minute_call'], label='Surf Plan', color='blue')
plt.bar(ultimate_call_avg.index, ultimate_call_avg['minute_call'], label='Ultimate Plan', color='red', alpha=0.5)
plt.xlabel('Month')
plt.ylabel('Average Call Minutes')
plt.title('Average Call Minutes Surf vs Ultimate')
plt.legend()
plt.show()

surf_std = round(surf_call_avg['minute_call'].std(), 1)
surf_var = round(surf_call_avg['minute_call'].var(), 1)
print('Surf:')
print(f'Standar Deviation for minute calls {surf_std}')
print(f'Varians for minute calls {surf_var}')
print()
ulti_std = round(ultimate_call_avg['minute_call'].std(), 1)
ulti_var = round(ultimate_call_avg['minute_call'].var(), 1)
# ultimate
print('Ultimate:')
print(f'Standar Deviation for minute calls {ulti_std}')
print(f'Varians for minute calls {ulti_var}')

sns.boxplot(data=surf_call_avg, x='minute_call')
plt.show()

sns.boxplot(data=ultimate_call_avg, x='minute_call')
plt.show()

"""Findings:

- Some Surf & Ultimate subscriber made a phone call exeding the package.
- Surf Standar Deviation for minute calls 144.6
- Surf Varians for minute calls 20909.7
- Ultimate Standar Deviation for minute calls 141.9
- Ultimate Varians for minute calls 20136.6

Insights:

- The monthly usage of Surf plan and Ultimate plan are increasing the same.
- Shockingly, cheap plan like Surf with limited time for call compared to Ultimate in some months have higher average of call time.
- Eventhough Surf price is cheaper with limited quota for call service, the average usage is the same with Ultimate plan.

### **Text**
"""

surf_sms_avg = pd.pivot_table(data_surf, index='month', values='sms', aggfunc='mean').reset_index()
ultimate_sms_avg = pd.pivot_table(data_ultimate, index='month', values='sms', aggfunc='mean').reset_index()

plt.bar(surf_sms_avg.index, surf_sms_avg['sms'], label='Surf Plan', color='blue')
plt.bar(ultimate_sms_avg.index, ultimate_sms_avg['sms'], label='Ultimate Plan', color='red', alpha=0.5)
plt.xlabel('Month')
plt.ylabel('Average SMS')
plt.title('Average SMS usage Surf vs Ultimate')
plt.legend()
plt.show()

plt.hist(surf_sms_avg['sms'], bins=10, color='blue')
plt.hist(ultimate_sms_avg['sms'], bins=10, color='red', alpha=0.3)
plt.show()

surf_std_sms = round(surf_sms_avg['sms'].std(), 1)
surf_var_sms = round(surf_sms_avg['sms'].var(), 1)
print('Surf:')
print(f'Standar Deviation for sms usage {surf_std_sms}')
print(f'Varians for sms usage {surf_var_sms}')
print()
ulti_std_sms = round(ultimate_sms_avg['sms'].std(), 1)
ulti_var_sms = round(ultimate_sms_avg['sms'].var(), 1)
# ultimate
print('Ultimate:')
print(f'Standar Deviation for sms usage {ulti_std_sms}')
print(f'Varians for sms usage {ulti_var_sms}')

sns.boxplot(data=surf_sms_avg, x='sms')
plt.show()

sns.boxplot(data=ultimate_sms_avg, x='sms')
plt.show()

"""Findings:

- Some Surf subscriber and Ultimate sent sms exeding the package.
- Surf Standar Deviation for sms usage 11.8
- Surf Varians for sms usage 140.2
- Ultimate Standar Deviation for sms usage 13.5
- Varians for sms usage 181.3

Insights:
- The monthly usage of Surf plan and Ultimate plan are increasing the same.
- It is rarely from Ultimate user to pass 1000 sms per month on average.

### **Internet**
"""

surf_data_avg = pd.pivot_table(data_surf, index='month', values='gb_used', aggfunc='mean').reset_index()
ultimate_data_avg = pd.pivot_table(data_ultimate, index='month', values='gb_used', aggfunc='mean').reset_index()

plt.bar(surf_data_avg.index, surf_data_avg['gb_used'], label='Surf Plan', color='blue')
plt.bar(ultimate_data_avg.index, ultimate_data_avg['gb_used'], label='Ultimate Plan', color='red', alpha=0.5)
plt.xlabel('Month')
plt.ylabel('Average internet usage')
plt.title('Average internet usage Surf vs Ultimate')
plt.legend()
plt.show()

plt.hist(surf_data_avg['gb_used'], bins=10, color='blue')
plt.hist(ultimate_data_avg['gb_used'], bins=10, color='red', alpha=0.3)
plt.show()

surf_std_data = round(surf_data_avg['gb_used'].std(), 1)
surf_var_data = round(surf_data_avg['gb_used'].var(), 1)
print('Surf:')
print(f'Standar Deviation for internet usage {surf_std_data}')
print(f'Varians for internet usage {surf_var_data}')
print()
ulti_std_data = round(ultimate_data_avg['gb_used'].std(), 1)
ulti_var_data = round(ultimate_data_avg['gb_used'].var(), 1)
# ultimate
print('Ultimate:')
print(f'Standar Deviation for internet usage {ulti_std_data}')
print(f'Varians for internet usage {ulti_var_data}')

sns.boxplot(data=surf_data_avg, x='gb_used')
plt.show()

sns.boxplot(data=ultimate_data_avg, x='gb_used')
plt.show()

"""Findings:

- Surf Standar Deviation for internet usage 5.7
- Surf Varians for internet usage 32.5
- Ultimate Standar Deviation for internet usage 5.5
- Varians for internet usage 30.4


Insights:
- The monthly usage of Surf plan and Ultimate plan are increasing the same.
- The average usage between both plan is relatively the same.

### **Revenue Stream**
"""

revenue_avg_surf = pd.pivot_table(data_surf, index='month', values='total_income', aggfunc='sum').reset_index()
revenue_avg_ultimate = pd.pivot_table(data_ultimate, index='month', values='total_income', aggfunc='sum').reset_index()

plt.bar(revenue_avg_surf.index, revenue_avg_surf['total_income'], label='Surf Plan', color='blue')
plt.bar(revenue_avg_ultimate.index, revenue_avg_ultimate['total_income'], label='Ultimate Plan', color='red', alpha=0.5)
plt.xlabel('Month')
plt.ylabel('Total income')
plt.title('Total income usage Surf vs Ultimate')
plt.legend()
plt.show()

surf_std_rev = round(revenue_avg_surf['total_income'].std(), 1)
surf_var_rev = round(revenue_avg_surf['total_income'].var(), 1)
print('Surf:')
print(f'Standar Deviation for total income {surf_std_rev}')
print(f'Varians for total income {surf_var_rev}')
print()
ulti_std_rev = round(revenue_avg_ultimate['total_income'].std(), 1)
ulti_var_rev = round(revenue_avg_ultimate['total_income'].var(), 1)
# ultimate
print('Ultimate:')
print(f'Standar Deviation for total income {ulti_std_rev}')
print(f'Varians for total income {ulti_var_rev}')

sns.boxplot(data=revenue_avg_surf, x='total_income')
plt.show()

sns.boxplot(data=revenue_avg_ultimate, x='total_income')
plt.show()

"""Findings:

- Surf Standar Deviation for total income 3740.1
- Surf Varians for total income 13988486.5
- Ultimate Standar Deviation for total income 6.8
- Ultimate Varians for total income 45.7


Insights:
- Compared to Ultimate, Surf total income are more vary.
- Started with lower number of revenue in 2018, Surf plan steadily grew compare to the stagnancy of Ultimate plan revenue.

## **Testing Statistical Hypotheses**

### **Hypothesis No.1**

Let's test the hypothesis, in this case we will use two sample t-test independent for statistical testing with H0 and H1 as below:

- H0 = The average usage of line service for Surf's clients and Ultimate's clients are same.
- H1 = The average usage of line service for Surf's clients and Ultimate's clients are not the same.

We will set alpha as follow:

- Alpha = 5%
"""

main_data_6.info()

calls_avg = pd.pivot_table(main_data_6, index='user_id', values='minute_call', columns='plan', aggfunc='mean').reset_index()
calls_avg

alpha = 0.05
p_value = ttest_ind(calls_avg['surf'], calls_avg['ultimate'], nan_policy='omit').pvalue
print(f'P-Value: {p_value}')
if p_value >= alpha:
    print("H0 Diterima: The average usage of line service for Surfs client's and Ultimate's clients are same")
else:
    print("H1 Diterima: The average usage of line service for Surf's clients and Ultimate's clients are not the same")
print('Surf average call', calls_avg['surf'].mean())
print('Ultimate average call', calls_avg['ultimate'].mean())

"""### **Hypothesis No.2**

Let's test the hypothesis, in this case we will use two sample t-test independent for statistical testing with H0 and H1 as below:

- H0 = The average revenue of NY-NJ area with others area are same.
- H1 = The average revenue of NY-NJ area with others area are not the same.

We will set alpha as follow:

- Alpha = 5%
"""

rev_avg = pd.pivot_table(main_data_6, index='user_id', columns='nynj', values='total_income', aggfunc='mean').reset_index()
rev_avg

alpha = 0.05
p_value = ttest_ind(rev_avg[1], rev_avg[0], nan_policy='omit').pvalue

print(f'P-Value: {p_value}')

if p_value >= alpha:
    print("H0 Accepted: The average revenue of NY-NJ area is the same as other areas")
else:
    print("H1 Accepted: The average revenue of NY-NJ area is not the same as other areas")

print('Average revenue for NY-NJ area:', rev_avg[1].mean())
print('Average revenue for Non NY-NJ areas:', rev_avg[0].mean())

"""## **General Conclusion**

**General**

The aim of this project is to compare two plans offered by Megaline company in order to understand which plan is the most profitable one.

The method used in this project is by answer 2 hypothesis which are:

1. The average usage of line service for Surf's clients and Ultimate's clients are same.
2. The average revenue of NY-NJ area with others area are same.

**Data Processing**

During the data processing we faced some obstacle and we did some action in order to have valid data to analyze. The procedure as well stated as bellow:

1. Data User

- column churn_date has blank value because those customers are still using our service. (Leave it that way because it does not bother other data).
- column reg_date and churn_date have value of object where it is supposed to be date format. (Reformat type using to_datetime)

2. Data Calls

- column call_date has object format when it is supposed to be date format. (Reformat type using to_datetime)

3. Data Messages

- column message_date has object format when it is supposed to be date format. (Reformat type using to_datetime)

4. Data Internet

- column session_date has object format when it is supposed to be date format. (Reformat type using to_datetime)

After we done correcting the data above we continue the process as bellow:

1. Creating column that needed for analysis (Usage of each service and its revenue and total revenue)
2. Categorize state so we can get NY-NJ state to compare with other states.
3. Combine all data into one named main_data_6.

**Exploratory Data Analysis**

1. Calls Service

Findings:

- Some Surf & Ultimate subscriber made a phone call exeding the package.
- Surf Standar Deviation for minute calls 144.6
- Surf Varians for minute calls 20909.7
- Ultimate Standar Deviation for minute calls 141.9
- Ultimate Varians for minute calls 20136.6

Insights:
- The monthly usage of Surf plan and Ultimate plan are increasing the same.
- Shockingly, cheap plan like Surf with limited time for call compared to Ultimate in some months have higher average of call time.
- Eventhough Surf price is cheaper with limited quota for call service, the average usage is the same with Ultimate plan.


2. SMS Service

Findings:

- Some Surf subscriber and Ultimate sent sms exeding the package.
- Surf Standar Deviation for sms usage 11.8
- Surf Varians for sms usage 140.2
- Ultimate Standar Deviation for sms usage 13.5
- Varians for sms usage 181.3

Insights:
- The monthly usage of Surf plan and Ultimate plan are increasing the same.
- It is rarely from Ultimate user to pass 1000 sms per month on average.


3. Internet Service

Findings:

- Surf Standar Deviation for internet usage 5.7
- Surf Varians for internet usage 32.5
- Ultimate Standar Deviation for internet usage 5.5
- Varians for internet usage 30.4

Insights:
- The monthly usage of Surf plan and Ultimate plan are increasing the same.
- The average usage between both plan is relatively the same.

**Hypothesis Testing**

1. The average usage of line service for Surfs client's and Ultimate's clients are same
2. The average revenue of NY-NJ area is the same as other areas

**Final Summary**

Based on the calculation we can see that:

1. The revenue from Ultimate plan tend to be stagnant through out the year of 2018.
2. In contrast, started lower than Ultimate plan, the positive trend showed by Surf plan.
3. Surf plan offered small based price, eventhough the excess fee much expensive than Ultimate plan, the customer sees this as safer option.
4. To support point 3, on average the usage of Ultimate and Surf are almost the same, meaning Ultimate plan on average quota are unused.
5. Surf plan customer might found point 3 and point 4 and choosed surf plan because of cheap base tariff and offered flexibility.
6. On average there is no different in revenue for customer in New York New Jersey area compared to the rest of the states.

Recommendation.
1. The sales need to focus on Surf plan because of the positive trend showed throughout the year of 2018.
2. If there is no additional in operating cost regarding the based quota for Ultimate plan, the sales team need to consider to boost the sale of Ultimate plan as well.
3. Sales team need to consider new way to promote ultimate plan to avoid further stagnancy in revenue.
"""

